Das Backend ist dafür verantwortlich, die Webseitenanfragen zu verarbeiten und mit den richtigen Daten zu antworten. Es verwaltet die Abfragen auf verschiedenen Routen, prüft, ob der Nutzer autentifiziert und autorisiert ist und stellt eine Schnittstelle bereit, die die Abfragen des Klienten mit den korrekten HTTP-Seiten und Datenbanken verbindet.

\subsection{Node}
NodeJS ist eine JavaScript Laufzeitumgebung, die es ermöglicht, JavaScript Code auf einem Server auszuführen. Der Server beantwortet die Abfragen, welche vom Nutzer über das Frontend verschickt werden und verwaltet die Routen der Domäne, um den gewünschten Inhalt anzeigen zu können. Mit der Hilfe von Paketverwaltungswerkzeugen wie npm ist es möglich, Programmierpakete in das Projekt einzubinden.\\

Wie in \textit{package.json} definiert, handelt es sich bei der Datei \textit{server.js} um das Main-Programm. Wenn der Kommandozeilenbefehl \textit{node start} ausgeführt wird, wird der in \textit{server.js} definierte Quellcode ausgeführt.
Nachdem benötigte Pakete geladen wurden, werden mit der Hilfe von \textit{dotenv} Umgebungsvariablen definiert. Dies hat den Vorteil, dass privat zu haltende Informationen wie beispielsweise Passwörter und Schlüssel in einer weiteren Datei ausgelagert werden können, welche nicht durch git verfolgt wird und auch von den Benutzern nicht einsehbar ist. Dies erhöht die Sicherheit, da sich sonst unautorisierte Personen leicht Zugriff zum System verschaffen könnten. Außerdem können damit für Entwicklungs- und Produktionsumgebung verschiedene Umgebungsvariablen verwendet werden, ohne dass verschiedene Zweige im git-System notwendig sind.\\

Danach verbindet sich der Node-Server mit der Datenbank, welche über MongoDB Atlas gehosted wird. Das verwendete Mongoose-Paket erlaubt mit Hilfe einer URI, welche den Anmeldeschlüssel enthält, die Autorisierung des Servers. Nachdem der Server erfolgreich verbunden wurde, wird geprüft, ob es sich bei der Node-Umgebung um die Produktiv- oder die Entwicklungsumgebung handelt. In der Entwicklungsumgebung werden Pseudo-Daten für die Datenbank erstellt, die es dem Entwickler vereinfachen zu prüfen, ob sein Quellcode funktioniert.

Zuletzt werden die Express- und Apollo-Applikation gestartet und der Server danach endgültig aktiviert.

\subsection{Express}
HTTP-Abfragen an den Server werden durch Express verwaltet. Dabei gibt Routen und Middlewarefunktionen.

\subsubsection{Middleware}
Middlewarefunktionen sind Funktionen, die als Teil einer HTTP-Anfrage ausgelöst werden, wenn sie für die angefrage Route aktiviert sind. Middlewarefunktionen werden hintereinander verkettet, sobald die erste Funktion ausgeführt wurde und keinen Fehler zurückgegeben hat, wird die nächste Middlewarefunktion ausgeführt, bis zum Schluss die Routenfunktion antwortet. Middlewarefunktionen können genutzt werden, um Protokoll über die Webseitenzugriffe zu führen, Abfragen zu autorisieren oder fehlerhafte Abfragen zu blockieren.

\paragraph{CORS\\}
Um Abfragen des Frontends an das Backend zu erlauben, ist CORS (Cross-Origin Resource Sharing) notwendig. Per Same-Origin-Poicy (SOP) wären Zugriffe von einer Domäne auf die andere normalerweise nicht gestattet, CORS ermöglicht es, Abfragen vom Frontend - welches eine andere Domäne besitzt - zu ermöglichen. Die Miskonfiguration von CORS gefährdet die Integrität der Webseite, es ist daher ratsam, nur für spezielle Domänen - in diesem Fall die Domäne des Frontends - CORS zu erlauben. Aktuell ist CORS für alle Abfragen erlaubt, um die Webseite sicherer zu gestalten muss in Zukunft die CORS-Richtlinie restriktiver eingestellt werden. Wenn die CORS-Regeln verletzt werden, wird eine Fehlermeldung ausgegeben und keine weiteren Funktionen der Kette zum Beantworten der HTTP-Anfrage ausgeführt.

\paragraph{JWT\\}
Einige Daten der Schnittstelle sind öffentlich. Andere Daten, wie zum Beispiel private Nutzerdaten, benötigen stattdessen eine Anfrage des jeweiligen Nutzers. Um die Autorität des Nutzers zu bestätigen wird beim Anmeldeprozess ein JSON Web Token (JWT) nach RFC-7519 Standard an den Klienten verschickt\cite{RFC7519}. Bei allen Folgeabfragen, so auch einer Abfrage der privaten Nutzerdaten, wird das Token als Teil des Anfragekopfes (request header) an das Backend gesendet. Durch Middleware wird das Token kontrolliert und der Nutzer authentifiziert und autorisiert. Das entschlüsselte Token wird an die folgenden Funktionen weitergeleitet und kann von diesen genutzt werden, um den abfragenden Benutzer herauszufinden. Sollte zum Beispiel eine Anfrage an die GraphQL-Schnittstelle gesendet werden, wird zuerst das JWT entschlüsselt und der Nutzer in die Abfrage hinzugefügt. Ohne die Middleware wäre die Datenbankschnittstelle, welche das Profil des aktuellen Nutzers anzeigt, nicht verwendbar.

\subsubsection{Routen}
Routen geben an, welcher Inhalt bei einer HTTP-Anfrage zurückgegeben werden soll.

\paragraph{Root ('/')\\}
Um zu prüfen, ob das Backend generell auf Abfragen reagiert, soll zunächst die Antwort bei der Abfrage des Stammverzeichnisses beantwortet werden.
\begin{lstlisting}
    app.get('/', (request, response) => {
        response.send('Hello')
    })
\end{lstlisting}
Bei einer GET-Anfrage des Stammverzeichnisses wird in diesem Fall mit \textit{\glqq Hallo \grqq} geantwortet. In Zukunft wird die Webseite hier mit der Homepage antworten, auf der grndlegende Informationen zur Seite zu finden sein werden.

\paragraph{/graphql\\}
Eine Anfrage an die Route \textit{/graphql} wird von Apollo, dem gewählten Framework für GraphQL beantwortet. Der Großteil aller Abfragen an das Backend gehen an diesen Endpunkt. Genauere Informationen zu GraphQL und Apollo sind in dem entsprechenden Kapitel zu finden. Durch die gewählten Optionen ist der GraphQL-Playground aktiviert, eine graphische Oberfläche die es einem benutzer der API ermöglicht, seine Abfragen direkt auf der Webseite in einem Texteditor zu schreiben. Durch das Erlauben von Introspektion steht zudem eine umfangreiche Dokumentation der möglichen Abfragen und deren Datentypen zur Verfügung, welche es dem Entwickler vereinfachen, seine eigenen Abfragen zu testen.

%Grafik?

\paragraph{/api\\}
Das Hochladen von Bildern ließ sich über GraphQL nicht zur Zufriedenheit lösen. Es wurde daher eine klassische, REST-basierte Lösung entwickelt, welche es mit Hilfe von Multer - einer Node Middleware zum behandeln von Multipart-Daten, worunter Bilddateien zählen - ermöglicht, Bilddateien auf AWS hochzuladen und die URI des hochgeladenen Bildes in MongoDB zu speichern. Dazu werden mit Hilfe des \textit{aws-sdk} Paketes die verwendeten Umgebungsvariablen für die Autorisierung bei AWS und der Wahl der Region und Schnittstellenversion verwendet. 

Wenn ein Nutzer ein Profilbild hochladen will, wird dafür die Subroute \textit{/avatar}, im vollen also \textit{/api/avatar} verwendet. Durch verschiedene Regeln wird mit Hilfe von Multer getestet, ob es sich bei der vom Nutzer gesendeten Ladung des Paketes (Payload) um eine Datei handelt, diese in einem akzeptierten Bildvormat ist und die maximale Dateigröße nicht überschritten wurde. Sollten alle Tests erfolgreich sein, wird das Bild mit einem durch UUID Version 4 generierten Namen auf S3 hochgeladen, ansonsten wird der entsprechende HTTP-Fehlercode angezeigt (4xx). Um das Bild öffentlich anbieten zu können, wird die Zugriffskontrollliste auf öffentlich lesbar gestellt. Schlussendlich wird der durch S3 generierte Link der Datei auf der Datenbank dem entsprechenden Nutzer zugewiesen.

Die Route \textit{/avatar} steht nur für POST-, aber nicht für GET-Afragen zur Verfügung. Für das Abfragen des Profilbilds wird stattdessen die GraphQL-Schnittstelle verwendet, die auch sonst für die meisten Abfragen verwendet wird. GET-Abfragen der Bilddateien stellen kein Problem dar, da die Datenbank lediglich einen Link des Bildes speichert und S3 beim öffnen dieses Links das Bild zurück gibt.

In Zukunft können weitere Subrouten für \textit{/api} erstellt werden, die zum Beispiel mit Multer in der Lage sind, auf Schnittstellenabfragen zu antworten. So könnte in einer späteren Version der Nutzer in der Lage sein, Bilder in Nachrichtenverläufen zu versenden, in diesem Fall würde, ähnlich wie bei \textit{/avatar}, die Route \textit{/chat} mit Hilfe von AWS S3 und Multer zum Hochladen von Bildern dienen.

\subsection{Mongoose}
Die im Kapitel Datenbanken beschriebenen Schemata werden in Mongoose definiert. Dazu wird mit \textit{new mongoose.Schema} ein neues Schema erstellt, in welchem die verschiedenen Felder sowie deren Datentypen und Restriktionen, wie eine minimale/maximale Länge einer Zeichenkette, Einzigartigkeit oder Validierungsfunktionen, welche das Feld erfüllen muss, gewählt werden. Nach der Definition des Schemas können komplexere Funktionen erstellt werden. Mit einer Funktion \textit{UserSchema.pre('save', function (next) {...})} wird so beispielsweise geprüft, ob der Benutzer den selben Nutzer beim Speichern einer Änderung danach mehrmals in der Freundesliste haben würde - in diesem Fall werden Duplikate gelöscht, bevor das Dokument final verändert wird.

\subsection{GraphQL}
Um Mongoose mit der GraphQL-Schnittstelle zu verbinden, wird das Paket \textit{graphql-compose-mongoose} verwendet. Das Paket erlaubt es, auf Basis des erstellten Schemas mit dem Befehl \textit{composeMongoose} die korrespondierenden GraphQL Typen und einige der meist verwendeten Abfragen und Mutationen automatisch zu generieren. Dies spart Arbeitszeit und hat den Vorteil, dass sich der GraphQL-Endpunkt automatisch anpasst, wenn Aktualisierungen am darunterliegenden Datenbankschema durchgeführt werden.