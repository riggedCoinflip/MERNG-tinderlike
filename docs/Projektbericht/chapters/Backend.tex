Das Backend stellt Endpunkte bereit, die in der Lage sind, auf HTTP-Anfragen zu antworten.
Damit dient das Backend unter anderem als Bindeglied zwischen Frontend und Datenbank.
Auch können durch verschiedene Funktionen Nutzer autentifiziert und autorisiert werden.
Dies ist für manche Datenbankabfragen, wie zum Beispiel das Ändern des eigenen Profils, Voraussetzung.

\subsection{Node}
\paragraph{}
NodeJS ist eine JavaScript Laufzeitumgebung, die es ermöglicht, JavaScript Code auf einem Server auszuführen \cite{be:node}.
Der Server beantwortet die Abfragen, welche vom Nutzer über das Frontend verschickt werden und verwaltet die Routen der Domäne, um den gewünschten Inhalt anzeigen zu können.
Mit der Hilfe von Paketverwaltungswerkzeugen wie npm ist es möglich, Programmierpakete in das Projekt einzubinden \cite{be:npm}.\\

\paragraph{}
Der Kommandozeilenbefehl \textit{node start} wird ausgeführt, um das Hauptprogramm \textit{server.js} auszuführen.
Das verwendete \textit{dotenv}-Paket erlaubt es, eine Datei mit dem Namen \textit{.env} zu erstellen, mit der Umgebungsvariablen definiert werden \cite{be:dotenv}.
Die Datei wird nicht durch git verfolgt, da sonst geheime Informationen wie Passwörter und Zugriffsschlüssel öffentlich wären.
Diese komprommitierten Daten würden Angreifern leichten Zugriff in das System geben.
Durch die Verwendung des Paketes können zudem verschiedene Umgebungsvariablen für Entwicklungs-, Test- und Produktionsumgebung verwendet werden.\cite{be:dotenv2}\\

\paragraph{}
Nach der Definition der Umgebungsvariablen verbindet sich der Node-Server mit der Mongo-Datenbank.
Dazu wird im verwendeten Paket \text{Mongoose} eine URL angegeben, welche einen Anmeldeschlüssel enthält \cite{be:mongoose}.
Zuletzt werden die Express- und Apollo-App gestartet und der Server danach endgültig aktiviert.

\subsection{Express}
Das minimalistische
Paket ExpressJS erlaubt die Definition von Routen und Middleware \cite{be:express}\cite{be:expressRouting}\cite{be:expressMiddleware}. \\

\subsubsection{Routen}
Routen geben an, welcher Inhalt bei einer HTTP-Anfrage zurückgegeben werden soll.
Die Express-Funtkionen definieren, auf welche REST-Methode (GET,POST,\dots) und auf welchem Pfad diese ausgeführt werden sollen.
Die Funktion hat Zugriff auf die Anfrage des Nutzers (request) und erstellt daraufhin eine Antwort (response).


\paragraph{Root ('/')\\}
Bei einer GET-Anfrage auf das Stammverzeichnis wird mit \enquote{Hello World!} geantwortet.
\begin{lstlisting}
    app.get('/', (request, response) => {
        response.send('Hello World!')
    })
\end{lstlisting}
In Zukunft wird hier mit der Homepage geantwortet werden, auf der das Projekt beschrieben wird.
Aktuell dient die Route als Platzhalter.

\paragraph{/graphql\\}
Eine Anfrage an die Route \textit{/graphql} wird von Apollo, dem gewählten Framework für GraphQL, beantwortet.
Der Großteil aller Abfragen an das Backend gehen an diesen Endpunkt.
Durch die für Apollo getätigten Einstellungen ist GraphiQL aktiviert, eine graphische Oberfläche, die die Benutzung der Datenbankschnittstelle erleichtert.
Durch Introspektion (eine Apollo-Einstellung) steht eine umfangreiche Dokumentation der möglichen Abfragen und deren Datentypen zur Verfügung.
Dies erleichtert das Schreiben von Schnittstellenabfragen.
Genauere Informationen zu GraphQL und Apollo sind in dem entsprechenden Kapitel zu finden.

\paragraph{/api\\}
GraphQL unterstützt nativ nur eingeschränkte Möglichkeiten zum Hochladen von Multipart-Dateien wie Bildern \cite{be:graphQlTypes}.
ES wurde sich daher für einen klassischen REST-Endpunkt entschieden.
Mit Hilfe des Paketes Multer werden die Bilddateien auf AWS S3 gespeichert \cite{be:multer}\cite{be:multerS3}.
Die Autorisierung von AWS wird dabei durch das Paket \textit{aws-sdk} gelöst.\\

Zum Erstellen von Profilbildern wird die Subroute \textit{/avatar} verwendet.
Mit Hilfe von Multer werden verschiedene Regeln definiert, welche testen, ob es sich bei der hochgeladenen Datei auch wirklich um ein Bild handelt und die maximale Dateigröße nicht überschritten wird.
Sollten alle Tests erfolgreich sein, wird das Bild mit einem durch UUID Version 4 generiertem Dateinamen auf S3 hochgeladen.
Um das Bild öffentlich verfügbar zu machen, muss die Zugriffskontrollliste von AWS für dieses Bild auf \enquote{öffentlich lesbar} gesetzt werden.
Zum Schluss wird die URL des generierten Bildes im Nutzerdokument abgelegt, um eine Referenz auf das Bild zu erhalten.\\

Die Route \textit{/avatar} steht nur für POST-Anfragen zur Verfügung.
Für die Äquivalente GET-Abfrage wird die GraphQL-Schnittstelle verwendet.
Dies ist möglich, da nur die URL der AWS-Datei, aber nicht das Bild selbst zurückgegeben wird.
Die URL wird dann im HTML-Dokument vom Nutzer geöffnet.\\

In Zukunft können weitere Subrouten für \textit{/api} erstellt werden, die zum Beispiel mit \textit{Multer} in der Lage sind, auf Schnittstellenabfragen zu antworten.
Eine mögliche Funktionalität wäre das Hochladen von Bildern in Chats.
Hier würden AWS S3 und Multer wieder zur Verwendung kommen, da die Anforderungen denen von \textit{/avatar} größtenteils entsprechen.

\subsubsection{Middleware}
\enquote{Middlewarefunktionen sind Funktionen, die Zugriff auf das Anforderungsobjekt (req), das Antwortobjekt (res) und die nächste Middlewarefunktion im Anforderung/Antwort-Zyklus der Anwendung haben. Die nächste Middlewarefunktion wird im Allgemeinen durch die Variable next bezeichnet.}\cite{be:expressMiddlewareQuote}
Middlewarefunktionen lassen sich sowohl auf Anwendungsebene als auch für einzelne Routen definieren.
Mögliche Ziele der Funktionen sind: Die Protokollierung von Webseitenzugriffen, die Autorisierung von Anfragen und die Blockierung von fehlerhafte Anfragen.

\paragraph{CORS\\}
Per Same-Origin-Poicy (SOP) sind Zugriffe von einer Domäne auf die andere normalerweise nicht gestattet \cite{be:mdnSop}.
Dies unterbindet Abfragen des Frontends an das Backend, da Frontend und Backend unter verschiedenen Servern laufen.
Durch CORS (Cross-Origin Recource Sharing) können Ausnahmen für SOP erstellt werden \cite{be:mdnCors}.
Eine vom Express-Paket gelieferte Middleware wird verwendet, welche es erlaubt, CORS zu aktivieren \cite{be:expressMiddlewareCors}.

\paragraph{JWT\\}
Einige Daten der Datenbankschnittstelle sind öffentlich verfügbar.
Manche Daten, wie zum Beispiel private Nutzerdaten, benötigen stattdessen eine Autorisierung für den Zugriff.
Um die Autorität des Nutzers zu bestätigen, wird beim Anmeldeprozess ein JSON Web Token (JWT) nach RFC-7519 Standard an den Klienten verschickt\cite{be:rfc7519}.
Bei allen Folgeabfragen, so auch einer Abfrage der privaten Nutzerdaten, wird das Token als Teil des Anfragekopfes (request header) an das Backend gesendet.
Eine Middlewarefunktion validiert und entschlüsselt das Token und fügt der Anfrage die Daten des entschlüsselten Tokens hinzu.
Die Datenbankschnittstelle nutzt die Daten des entschlüsselten Tokens um zu entscheiden, ob der Nutzer für die Abfrage autorisiert ist.

%Grafik?

\subsection{Mongoose}
Die im Kapitel Datenbanken beschriebenen Schemata werden in Mongoose definiert.
Dazu wird mit \textit{new mongoose.Schema} ein neues Schema erstellt, welches die Datentypen und mögliche Restriktionen (minimale/maximale Länge, Einzigartigkeit,\dots) definiert\cite{be:mongooseSchema}.
Das Schema gibt an, welche Struktur die Dokumente der entsprechenden Kollektion aufweisen sollen.\\
Mongoose erlaubt die Definition von Middlewarefunktionen, die zum Beispiel beim Speichern oder Aktualisieren eines Dokumentes feuern sollen\cite{be:mongooseMiddleware}.
Damit wird unter anderem geprüft, ob sich zwei Nuter gegenseitig einen \textit{like} gegeben haben, um diese dann zu befreunden.

\subsection{GraphQL}
Um Mongoose mit der GraphQL-Schnittstelle zu verbinden, werden die Pakete \textit{graphql-compose} und \textit{graphql-compose-mongoose} verwendet.
Dies erlaubt es, auf Basis des erstellten Schemas mit dem Befehl \textit{composeMongoose} die korrespondierenden GraphQL Typen und einige der meist verwendeten Abfragen und Mutationen automatisch zu generieren\cite{be:graphqlComposeMongoose}.
Dies spart Arbeitszeit und hat den Vorteil, dass sich der GraphQL-Endpunkt automatisch anpasst, wenn Aktualisierungen am darunterliegenden Datenbankschema durchgeführt werden.