\subsection{Anforderungen und Technologiewahl}
Die Webseite besteht aus statischen Inhalten wie beispielsweise der Menuführung, die offen im HTML-Dokument liegen und Inhalten, die dynamisch mit Daten aus der Datenbank gefüllt werden: Profile, Chats, Nachrichten. Um diese Daten bereitstellen zu können, ist eine Schnittstelle zwischen Datenbank und Frontend notwendig. 

Es wurde sich für GraphQL statt einer standardmäßigen REST-Schnittstelle entschieden, da GraphQL verschiedene Verbesserungen bietet, wie zum Beispiel Leistungsoptimierungen durch Overfetching und Underfetching, Stabilität durch ein Typenschema und Selbstdokumentation.

\subsection{Overfetching und Underfetching}
Antworten von REST-Schnittstellen sind dafür bekannt, zu viele Daten (Overfetching) oder zu wenige Daten (Underfetching) zu beinhalten.
In beiden Fällen entstehen - durch mehr benötigte Bandbreite oder mehr Anfragen - Leistungseinbuße, die als Folge längere Antwortzeiten und höhere Serverkosten beinhalten.
Das Problem ist mit REST-Schnittstellen schwer zu umgehen, eine perfekte Konfiguration würde exakt die Endpunkte beinhalten, die genau die angefragen Daten liefern. Dies ist jedoch praxisfern, da sich die Anforderungen in einem Projekt ständig verändern und jeder Endpunkt für dessen Betrieb Ressourcen benötigt und gewartet und getestet werden muss.

GraphQL löst das Problem, indem bei jeder Anfrage genau definiert wird, welche Daten von welchen Endpunkten erfragt werden. Dies entlastet die Datenbank, da diese weniger Daten zur Verfügung stellen muss und erleichtert auch die Arbeit des Frontends, da nur eine Abfrage erstellt werden muss und irrelevante Daten bereits in der Abfrage aussortiert werden. REST fokussiert sich auf die verschiedenen Endpunkte, während bei GraphQL den Fokus auf die einzelnen Aufgaben legt. Die Applikation entscheidet über die Daten die es erhält, nicht der Server.
Mehrere Abfragen können in eine einzige Schnittstellenabfrage gebündelt werden, der Client erhält somit zusammenhängende Daten und die Datenbank wird durch präzise Abfragen geschont.

\subsection{Stabilität}
Durch GraphQls Typenschemata wird definiert, welche Abfragen und Mutationen möglich sind. Sollte bei einer Abfrage die Datenbank einen anderen Datentyp als durch das Typenschema definiert liefern, wirft GraphQL einen Fehler.  Der Klient kann somit bei einer Abfrage damit rechnen, Daten in den angegebenen Datentypen zu erhalten, Ausnahmen für andere Datentypen müssen nicht definiert werden. Genauso wird eine Abfrage mit nicht erlaubten Datentypen direkt mit einer Fehlermeldung beantwortet, die genau auf den falschen Datentyp hinweist. Dadurch werden Inkonsistenzen der Datenbank oder weitere Datentypenkontrollen durch Design bereits stark mitigiert.

\subsection{Dokumentation}
GraphQL selbstdokumentiert jeden Endpunkt durch die vorliegenden Datentypen. Bei Änderungen an der Schnittstelle wird die Dokumentation automatisch aktualisiert. Weiterhin kann manuell eine Beschreibung des Endpunkts hinzugefügt werden.
Dies erleichtert es dem Frontend, die richtigen Endpunkte und Datentypen für ihre Abfragen und Mutationen zu verwenden. Durch die angegebenen Datentypen ist das Frontend somit in der Lage, direkt zu erkennen, welche Datentypen in der entsprechenden Abfrage oder Mutation zu verwenden sind und kann damit Zeit sparen. Gleichzeitig fällt Zeit weg, die für das manuelle Dokumentieren der Schnittstelle angefallen wäre.

\subsection{GraphiQL}
Mit GraphiQL liefert GraphQL einen Webeditor, der das Schreiben von Abfragen und Mutationen vereinfacht. Der Editor liefert einige Funktionen, die den Umgang einfacher machen, wie zum Beispiel automatisches Komplettieren von Variablennamen oder das Formatieren in eine lesbarere Struktur. Der Editor hat außerdem Zugriff auf die Typenschemata und Dokumentation und kann damit Abfragen auf syntaktische Fehler untersuchen, noch bevor diese abgeschickt werden.
Der Editor steht unter der Route \textit{/graphql} für jeden Nutzer zur freien Verfügung und erleichtert somit die Arbeit für alle Programmierer, die unsere Schnittstelle verwenden. Im Projekt konnte durch die Nutzung des Editors beim Erstellen von Datentypdefinitionen, Abfragen und Mutationen Programmierzeit gespart werden.

\begin{figure}
	\centering
    \includegraphics[width=\textwidth]{sources/graphiql.png}\cite{}
	\caption{GraphiQL Benutzeroberfläche. Links: Zwei Endpunkte werden durch eine Abfrage gebündelt abgefragt. Mitte: Antwort der Endpunkte. Rechts: Dokumentation und Typendefinition des Endpunkts \texitit{userSelf}.}
	\label{fig1}
\end{figure}

\subsection{Resolver}
Durch die Pakete \textit{graphql-compose} und \textit{graphql-compose-mongoose} werden aus den bestehenden Datenbankmodellen Typenschemata entsprechend der Datentypen erstellt, die in GraphQL weiterverwendet werden können. 
Resolver ("to resolve", etw. auflösen/abwickeln/klären) beantworten Abfragen und Mutationen. Sie bilden das Bindeglied zwischen Schnittstellenabfrage und Datenbankantwort. So wird beispielsweise eine Schnittstellenabfrage, welche nach dem Namen, Alter und Freitext des Nutzers "Foobar" fragt, durch einen Resolver in die entsprechende Datenbankabfrage übersetzt und die Antwort der Datenbank wiederum so editiert, dass diese der gewünschten Datenstruktur der Abfrage entspricht. Simplere Resolver, welche zum Beispiel einen einzelnen Datenbankeintrag durch die ID identifizieren (\textit{findOne}) oder anhand der bestehenden Datenstruktur einen Datenbankeintrag erstellen (\textit{createOne}), werden durch die verwendeten Pakete bereit gestellt und lassen sich in das Projekt integrieren, für komplexere Resolver lassen sich bestehende anpassen oder gänzlich neue erstellen.
Die verwendeten Resolver und Typenschemata werden dem \textit{schemaComposer} bereit gestellt, welcher aus den bestehenden Daten die Dokumentation generiert.


\subsection{Verwendete Abfragen und Mutationen}
Nachfolgend werden einige der verwendeten Abfragen und Mutationen exemplarisch vorgestellt.

Für den Registrierungsvorgang wird die Mutation \textit{signup} verwendet. Durch die Angabe von Email, gewünschtem Namen und Passwort wird ein Nutzerkonto erstellt. In Zukunft kann durch Angabe von Namen und Passwort mit der \textit{login} Abfrage ein Authentifizierungstoken erstellt werden, welches bei Abfragen, die eine Authentifizierung oder Authorisierung verlangen, benötigt wird.

\begin{figure}
	\centering
    \includegraphics[width=\textwidth]{sources/graphiql_signup.png}\cite{}
	\caption{Registrierung des neuen Nutzers \textit{MyName}}
	\label{fig2}

\end{figure}\begin{figure}
	\centering
    \includegraphics[width=\textwidth]{sources/}\cite{}
	\caption{Anmeldung des Nutzers. Die Antwort enthält das JSON Web Token, welches für bestimmte Abfragen zur Authentifizierung und Autorisierung dient.}
	\label{fig3}
\end{figure}

Alle weiteren vorgestellten Endpunkte benötigen zur eindeitugen Indentifizierung ein valides Authentifizierungstoken.

Um das eigene Profil anzuzeigen, wird die \textit{userSelf} Abfrage verwendet. Diese zeigt Daten entsprechend des Datenbankschemas an. Einige dieser Daten sind veränderbar, so zum Beispiel der Freitext. Zum Verändern der Daten ist die Mutation \textit{userUpdateSelf} vonnöten.

\begin{figure}
	\centering
    \includegraphics[width=\textwidth]{sources/graphiql_userUpdateSelf.png}\cite{}
	\caption{Das Geschlecht, Sprachen, Rolle etc. für den aktiven Nuter werden gesetzt. Unten: Ausschnitt des Autorisierungstokens. Durch das Token wird der aktive Nutzer identifiziert.}
	\label{fig4}
\end{figure}

Zum Finden von neuen Nutzern wird die Abfrage \texit{userManyToSwipe} verwendet. Dabei werden dem abfragendem Nutzer durch einen Algorithmus die Profile von mehreren Nutzern geladen, die sich nicht bereits in der Freundesliste befinden oder vom aktiven Nutzer blockiert wurden. Nutzer, welche dem aktiven Nutzer eine Freundesanfrage geschickt haben, werden präferiert gezeigt, um die Chance neuer Freundschaften zu erhöhen. Es ist möglich, durch Filter die Menge der potenziellen Nuter zu reduzieren. Im Frontend werden die Profile nacheinander angezeigt. Hier hätte man überlegen können, mit jeder Abfrage nur einen einzelnen Nutzer anzuzeigen, da das Laden von mehreren Nutzern pro Abfrage jedoch die Zahl der Abfragen stark erhöht wurde sich dagegen entschieden.
Mit der Mutation \textit{swipe} kann dann eine Freundschaftsanfrage an den angegebenen Nutzer geschickt werden.

\begin{figure}
	\centering
    \includegraphics[width=\textwidth]{sources/graphiql_userManyToSwipe.png}\cite{}
	\caption{Abfrage nach mehreren Nutzern mit userManyToSwipe. Durch den Filter werden nur Nutzer im Alter zwischen 20 und 30 Jahren angezeigt.}
	\label{fig5}
\end{figure}

\begin{figure}
	\centering
    \includegraphics[width=\textwidth]{sources/graphiql_swipe.png}\cite{}
	\caption{Der aktive Nutzer versendet einen Like an den durch \textit{recipient} definierten Nutzer}
	\label{fig6}
\end{figure}

Die Nachrichten eines Chats können durch die Abfrage \textit{getChat} gelesen werden. Dazu ist die ID des Chat anzugeben. Der optionale Parameter "Seite" gibt an, welche Nachrichten zurückgegeben werden sollen. Auf jeder Seite befinden sich 20 Nachrichten, beginnend bei "Seite=1" mit den neuesten 20 Nachrichten. Sollte der Seitenparameter nicht angegeben werden, wird nur die neueste Nachricht geladen, dies wird bei der Vorschau des Chats für die Freundesliste verwendet.

\begin{figure}
	\centering
    \includegraphics[width=\textwidth]{sources/graphiql_getChat.png}\cite{}
	\caption{Durch den Parameter \texit{page: 1} werden die bis zu 20 letzten Nachrichten geladen. Da der Chat nur 4 Nachrichten beinhaltet werden nur diese geladen. Unten: Das Authentifizierungstoken \texitit{x-auth-token} befindet sich in dem HTTP-Header der Abfrage.}
	\label{fig7}
\end{figure}

Mit \textit{sendMessage} können Nachrichten versendet werden. Dazu ist die ID des Chats notwendig. Der im Parameter \textit{Inhalt} definierte Text wird dann in den Chat als neueste Nachricht versendet.
Sollte ein Nutzer eine Nachricht editieren oder löschen wollen, ist dazu die Mutation \textit{editOrDeleteMessage} zu verwenden. Zusätzlich zur Chat-ID ist die Nachrichten-ID der zu verändernden Nachricht anzugeben. Der optionale Parameter \textit{content} gibt im Falle einer Änderung den neuen Nachrichteninhalt an. Sollte \textit{content} nicht definiert sein, wird die gewählte Nachricht stattdessen gelöscht. 

\begin{figure}
	\centering
    \includegraphics[width=\textwidth]{sources/graphiql_editMessage.png}\cite{}
	\caption{Die bestehende Nachricht (Siehe Abfrage \textit{getChat}) wird durch den in \textit{content} definierten Text ersetzt.}
	\label{fig8}
\end{figure}

\begin{figure}
	\centering
    \includegraphics[width=\textwidth]{sources/graphiql_deleteMessage.png}\cite{}
	\caption{Die soeben editierte Nachricht wird gelöscht.}
	\label{fig9}
\end{figure}

\subsection{Fazit}
Mit Hilfe von GraphQL konnten Endpunkte für Abfragen geschaffen werden, welche sich auf der Webseite unter der Benutzeroberfläche befinden. ...